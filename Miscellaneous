#include <iostream>
#include <queue>
#include <limits.h>
using namespace std;

class Node{
    public:
    int data;
    Node* left;
    Node* right;

    Node(int _data):data(_data),left(NULL),right(NULL){}
};

class NodeData{
    public:
    int size;
    int maxVal;
    int minVal;
    bool validBST;
    NodeData(){}
    NodeData(int s,int max,int min,bool valid):size(s),maxVal(max),minVal(min),validBST(valid){}
};


Node* insertIntoBST(Node* root,int data){
    if(!root){
      // if first node
      root = new Node(data);
      return root;
    }

      // if not the first node
    if(root->data > data){
      // insert into left
      root->left = insertIntoBST(root->left,data);
    }
    else{
      // insert into right
      root->right = insertIntoBST(root->right,data);
    }

    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data != -1){
      root = insertIntoBST(root,data);
      cin>>data;
    }
}
void LevelOrderTraversal_PrintLevelWise(Node* root){
  queue<Node*> q;

  q.push(root);
  q.push(NULL);

  while(!q.empty()){

    Node* temp = q.front();
    q.pop();
    if(temp == NULL){
      cout<<endl;
      if(!q.empty()){
        q.push(NULL);
      }
    }
    else{
      cout<<temp->data<<" ";
      if(temp->left){
        q.push(temp->left);
      }
      if(temp->right){
        q.push(temp->right);
      }
    } 
  }
}


Node* BSTFromInorder(int inorder[],int s,int e){
  if(s>e){
    return NULL;
  }

  int mid = (s+e)/2;
  int element = inorder[mid];

  Node* root = new Node(element);

  root->left = BSTFromInorder(inorder,s,mid-1);
  root->right = BSTFromInorder(inorder,mid+1,e);

  return root;

}


void convertIntoSortedDLL(Node* root,Node* &head){
  if(!root) return;

  // right subtree solve
  convertIntoSortedDLL(root->right,head);

  // root connect
  root->right = head;

  if(head){
    head->left = root;
  }

  // update head
  head = root;

  // left subtree solve
  convertIntoSortedDLL(root->left,head);

}


Node* sortedDLLToBST(Node* &head,int n){
    if(n<=0 || !head) return 0;

    // solve left part
    Node* leftSubtree = sortedDLLToBST(head,n/2);

    // create root
    Node* root = head;
    // connect root to left part
    root->left = leftSubtree;

    // update head
    head = head->right;

    // solve for right part
    root->right = sortedDLLToBST(head,n/2-1);

    return root;
}

void printLL(Node* head){
  cout<<"Printing BST TO sorted DLL :"<<endl;
  Node* curr = head;
  while(curr){
    cout<<curr->data<<"->";
    curr = curr->right;
  }
  cout<<endl;
}


NodeData* largestBstFromBT(Node* root,int &ans){
  if(!root){
    NodeData temp(0,INT_MIN,INT_MAX,true); //size,max,min,valid
    return temp;
  }

  NodeData left = largestBstFromBT(root->left,ans);
  NodeData right = largestBstFromBT(root->right,ans);


  NodeData curr;

  curr.size = left.size + right.size + 1;
  curr.maxVal = max(root->data,right.maxVal);
  curr.minVal = min(root->data,left.minVal);
  
  if(left.validBST && right.validBST && (root->data > left.maxVal && root->data < right.minVal)){
      curr.validBST = true;
  }
  else{ 
      curr.validBST = false;
  }

  if(curr.validBST){
    ans = max(ans,curr.size);
  }
  return curr;

}

int main() {
  int inorder[] = {1,2,3,4,5,6,7,8,9};
  int s = 0;
  int e = 8;

   cout<<"BST From inorder :"<<endl;
  Node* root = BSTFromInorder(inorder,s,e);
  LevelOrderTraversal_PrintLevelWise(root);
  cout<<endl;

  Node* head = NULL;
  convertIntoSortedDLL(root,head);
  printLL(head);
  cout<<endl;
  
  cout<<"SortedDLL  to BST :"<<endl;
  Node* root1 = 0;
  root1 = sortedDLLToBST(head,9);
  LevelOrderTraversal_PrintLevelWise(root1);
  


}
